# 指示書: TDDによる`md2backlog`の実装

## はじめに

このドキュメントは、あなたが`md2backlog` CLIツールを実装するための手順書です。あなたは、`requirements.md`に記載された要件を、和田卓人（t-wada）氏が提唱するテスト駆動開発（TDD）のスタイルに厳密に従って実装しなければなりません。

一つずつ、着実に進めてください。

## TDDの基本原則

以下の原則を常に念頭に置いて開発を進めてください。

1.  **Red -> Green -> Refactor**
    -   **Red:** まず、失敗する小さなテストを一つだけ書きます。
    -   **Green:** 次に、そのテストをパスさせるための最小限のコードを書きます。（この段階では、ハードコーディングや非効率なコードでも構いません）
    -   **Refactor:** 最後に、テストが通っている状態を維持したまま、プロダクションコードとテストコードの両方をクリーンにします。

2.  **最小のステップで**
    -   常に、実装すべき機能のうち、最もシンプルで小さなものから着手してください。

3.  **テストコードは第一級市民**
    -   テストコードもプロダクションコードと同様に、可読性が高く、メンテナンスしやすい状態を保ってください。

## 品質チェック＆コミット
-   **コミット単位:** 各ステップの完了、または意味のある機能追加ごとにコミットを作成する。
-   **品質保証:** 各コミットの直前に、必ず`goimports`によるフォーマットと`golangci-lint`による静的解析を実行し、クリーンな状態のコードのみをコミットすること。

## 実装ステップ

以下の順序で、TDDサイクルを回しながら開発を進めてください。

### Step 0: プロジェクトのセットアップ

1.  `go mod init`でGoモジュールを初期化します。
2.  `requirements.md`で指定された`cobra`と`goldmark`を`go get`で追加します。
3.  基本的なディレクトリ構造（`cmd/`, `internal/`など）を作成します。

### Step 1: 最もシンプルなCLIの振る舞いを実装する

**目標:** `--version`フラグに応答する、何もしないCLIを完成させる。

1.  **(Red)** `md2backlog --version`を実行した際に、エラーなくバージョン番号（例: "0.1.0"）が標準出力に表示されることを検証する、最初のテストを書きます。
2.  **(Green)** このテストをパスさせるため、`cobra`を使って`version`コマンドを定義し、バージョン番号をハードコードで返す最小限のコードを`cmd/`以下に実装します。
3.  **(Refactor)** コードを整理します。

### Step 2: 標準入出力をパススルーさせる

**目標:** 標準入力で受け取った文字列を、そのまま標準出力に返す。

1.  **(Red)** `md2backlog`コマンドに"hello"という文字列を標準入力で与えると、"hello"という文字列が標準出力から得られることを検証するテストを書きます。この段階では、まだMarkdownの変換は行いません。
2.  **(Green)** 入力を読み取り、そのまま出力するロジックを実装します。
3.  **(Refactor)** コードを整理します。

### Step 3: 変換ロジックの骨格を作る

**目標:** 文字列を受け取り、文字列を返す変換関数の雛形を作る。

1.  **(Red)** `internal/converter`のようなパッケージに、`Convert(markdown string) (string, error)`というシグネチャを持つ関数を想定し、そのテストを書きます。テスト内容は、単純な文字列（例: "text"）を渡すと、同じ文字列が返ってくることを確認するものです。
2.  **(Green)** 上記テストをパスするよう、受け取った文字列をそのまま返すだけの`Convert`関数を実装します。
3.  **(Refactor)** パッケージ構造などを整理します。

### Step 4: 最初の変換ルール（見出し）を実装する

**目標:** `#`で始まる見出しを、`*`の見出しに変換する。

1.  **(Red)** `Convert`関数のテストに、`# heading`を渡すと`* heading`が返ってくる、というテストケースを追加します。このテストは失敗します。
2.  **(Green)** `goldmark`を使ってASTをパースし、見出しノード（`ast.KindHeading`）を見つけて、Backlog記法に変換する最小限のロジックを実装します。
3.  **(Refactor)** 変換ロジックをより汎用的な形（AST Walkerパターンなど）に整理します。

### Step 5: 変換ルールを一つずつ追加する

**目標:** `requirements.md`の変換ルールを、簡単なものから順にTDDで実装する。

以下の順序で、ルールごとに「Red -> Green -> Refactor」のサイクルを繰り返してください。一つのルールに対して、複数のテストケース（正常系、エッジケース）を追加することを推奨します。

1.  太字 (`**bold**`)
2.  斜体 (`*italic*`)
3.  打ち消し線 (`~~strike~~`)
4.  単一階層の箇条書きリスト (`- item`)
5.  ネストした箇条書きリスト (`-- item`)
6.  単一階層の番号付きリスト (`+ item`)
7.  リンク (`[text](url)`)
8.  インラインコード (`` `code` ``)
9.  コードブロック (``` ```)
10. ...その他のルールも同様に進める。

### Step 6: 非対応記法の変換を実装する

**目標:** Backlogにない記法の変換ルールを実装する。

1.  **(Red)** `requirements.md`で定義された非対応記法（タスクリスト、ネストした番号付きリストなど）の変換を検証するテストを書きます。（例: `- [ ] task`が`- task`になること）
2.  **(Green)** そのテストを通す実装を行います。
3.  **(Refactor)** 整理します。

### Step 7: 全体の統合と最終確認

1.  Step 5, 6で完成した`Convert`関数を、Step 2で作成したCLIの入出力ロジックに組み込みます。
2.  ファイル入出力（`-i`, `-o`フラグ）が正しく機能することを検証する統合テストを追加します。
3.  `requirements.md`に記載された全ての要件（CIの設定、Linterのパス、ドキュメントの整備など）が満たされていることを確認します。

以上のステップに従い、開発を開始してください。